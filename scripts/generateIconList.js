const fs = require('fs');
const path = require('path');

// Read all SVG files from public/icons/outline and public/icons/solid
const outlineDir = path.join(__dirname, '../public/icons/outline');
const solidDir = path.join(__dirname, '../public/icons/solid');

// Get categories from folder structure
function getCategoriesFromFolders(baseDir) {
  if (!fs.existsSync(baseDir)) {
    console.log(`Directory ${baseDir} does not exist`);
    return {};
  }

  const categories = {};
  const entries = fs.readdirSync(baseDir, { withFileTypes: true });

  entries.forEach(entry => {
    if (entry.isDirectory()) {
      // This is a category folder
      const categoryId = entry.name;
      const categoryPath = path.join(baseDir, categoryId);

      // Get all SVG files in this category
      const files = fs.readdirSync(categoryPath);
      const icons = files
        .filter(file => file.endsWith('.svg'))
        .map(file => file.replace('.svg', ''));

      if (icons.length > 0) {
        categories[categoryId] = icons;
      }
    }
  });

  return categories;
}

const outlineCategories = getCategoriesFromFolders(outlineDir);
const solidCategories = getCategoriesFromFolders(solidDir);

// Get all unique category IDs
const allCategoryIds = new Set([
  ...Object.keys(outlineCategories),
  ...Object.keys(solidCategories)
]);

console.log(`Found ${allCategoryIds.size} categories`);

// Build final categorized structure with icons that exist in both outline and solid
const categorized = {};
allCategoryIds.forEach(categoryId => {
  const outlineIcons = outlineCategories[categoryId] || [];
  const solidIcons = solidCategories[categoryId] || [];

  // Only include icons that exist in both outline and solid versions
  const commonIcons = outlineIcons.filter(icon => solidIcons.includes(icon));

  if (commonIcons.length > 0) {
    categorized[categoryId] = commonIcons;
    console.log(`  ${categoryId}: ${commonIcons.length} icons`);
  }
});

// Generate TypeScript file
const output = `// Auto-generated icon data from public/icons
// This file is generated by scripts/generateIconList.js
// DO NOT EDIT MANUALLY

export interface IconItem {
  name: string;
  componentName: string;
  category: string;
  keywords: string[];
}

export interface IconCategory {
  id: string;
  name: string;
  icons: IconItem[];
}

export const iconCategories: IconCategory[] = [
${Object.entries(categorized)
  .filter(([_, icons]) => icons.length > 0)
  .map(([category, icons]) => {
    // Convert category id to display name (e.g., "arrows" -> "Arrows", "system-icons" -> "System Icons")
    const categoryName = category
      .split('-')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');

    return `  {
    id: "${category}",
    name: "${categoryName}",
    icons: [
${icons.map(icon => `      { name: "${icon}", componentName: "${icon}", category: "${category}", keywords: ${JSON.stringify(icon.split('-'))} }`).join(',\n')}
    ]
  }`;
  })
  .join(',\n')}
];
`;

// Write to file
const outputPath = path.join(__dirname, '../lib/iconData.ts');
fs.writeFileSync(outputPath, output);

console.log(`\nGenerated ${outputPath}`);
console.log('Categories:', Object.keys(categorized).filter(k => categorized[k].length > 0));
