import svgtofont from 'svgtofont';
import path from 'path';
import fs from 'fs-extra';
import { fileURLToPath } from 'url';
import { glob } from 'glob';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

async function generateIconFont() {
  console.log('üé® Generating icon font with svgtofont...');

  try {
    // Create temp directory and copy all outline and solid SVGs to flat structure
    const tempDir = path.resolve(__dirname, '../.temp-icons');
    await fs.ensureDir(tempDir);
    await fs.emptyDir(tempDir);

    console.log('üìÅ Copying SVG files to temp directory...');

    // Get outline and solid SVGs
    const outlineSvgs = await glob('public/icons/outline/**/*.svg');
    const solidSvgs = await glob('public/icons/solid/**/*.svg');
    console.log(`‚úÖ Found ${outlineSvgs.length} outline + ${solidSvgs.length} solid SVG files`);

    // Copy outline icons (no suffix)
    for (const svgPath of outlineSvgs) {
      const fileName = path.basename(svgPath);
      await fs.copy(svgPath, path.join(tempDir, fileName));
    }

    // Copy solid icons with -fill suffix
    for (const svgPath of solidSvgs) {
      const baseName = path.basename(svgPath, '.svg');
      const fileName = `${baseName}-fill.svg`;
      await fs.copy(svgPath, path.join(tempDir, fileName));
    }

    // Generate icon font with both outline and filled icons
    await svgtofont({
      src: tempDir,
      dist: path.resolve(__dirname, '../dist'),
      fontName: 'uniline',
      css: true,
      classNamePrefix: 'uni',
      startUnicode: 0xE001,
      useNameAsUnicode: false,
      svgicons2svgfont: {
        fontHeight: 1000,
        normalize: true,
        centerHorizontally: true
      },
      website: {
        title: 'Uniline Icon Font',
        logo: '',
        description: 'Uniline - Complete icon font with outline and filled variants',
        links: [],
        footerInfo: 'Generated by svgtofont'
      }
    });

    // Clean up temp directory
    await fs.remove(tempDir);
    console.log('üßπ Cleaned up temp directory');

    // Post-process CSS to add mask-image support for outline icons
    const cssPath = path.resolve(__dirname, '../dist/uniline.css');
    let css = await fs.readFile(cssPath, 'utf8');

    // Find the base icon class styles and update them
    const baseClassMatch = css.match(/\[class\^\="uni-"\], \[class\*=" uni-"\] \{[^}]+\}/);
    if (baseClassMatch) {
      // Replace the base class with mask-image support
      css = css.replace(
        /\[class\^\="uni-"\], \[class\*=" uni-"\] \{[^}]+\}/,
        `[class^="uni-"], [class*=" uni-"] {
  font-family: 'uniline' !important;
  font-style: normal;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  display: inline-block;
  font-size: inherit;
  text-rendering: auto;
  line-height: 1;
}

/* Outline icons use mask for color support */
[class^="uni-"]:not([class*="-fill"])::before,
[class*=" uni-"]:not([class*="-fill"])::before {
  background-color: currentColor;
  -webkit-mask-size: 100% 100%;
  mask-size: 100% 100%;
  -webkit-mask-repeat: no-repeat;
  mask-repeat: no-repeat;
  -webkit-mask-position: center;
  mask-position: center;
}`
      );
    }

    // Add mask-image property for outline icons
    const outlineIconClasses = css.match(/\.uni-([a-z0-9-]+)::before { content: "\\e[0-9a-f]+"; }/g) || [];
    let maskStyles = '\n/* Outline icons - use mask-image for stroke rendering with color support */\n';

    for (const iconClass of outlineIconClasses) {
      const match = iconClass.match(/\.uni-([a-z0-9-]+)::before/);
      if (match) {
        const iconName = match[1];

        // Check if this is an outline icon (not a -fill variant)
        if (!iconName.endsWith('-fill')) {
          // Find the corresponding outline SVG
          const outlineSvg = outlineSvgs.find(svg => path.basename(svg, '.svg') === iconName);

          if (outlineSvg) {
            const svgContent = await fs.readFile(outlineSvg, 'utf8');
            const svgDataUri = svgToMaskDataUri(svgContent);

            if (svgDataUri) {
              maskStyles += `.uni-${iconName}::before {\n`;
              maskStyles += `  -webkit-mask-image: url("${svgDataUri}");\n`;
              maskStyles += `  mask-image: url("${svgDataUri}");\n`;
              maskStyles += `}\n`;
            }
          }
        }
      }
    }

    // Helper function to convert SVG to data URI for mask
    function svgToMaskDataUri(svgContent) {
      const viewBoxMatch = svgContent.match(/viewBox="([^"]+)"/);
      const viewBox = viewBoxMatch ? viewBoxMatch[1] : '0 0 24 24';
      const contentMatch = svgContent.match(/<svg[^>]*>([\s\S]*?)<\/svg>/);

      if (!contentMatch) return '';

      // Remove existing stroke-width attributes from the inner content
      let innerContent = contentMatch[1].trim();
      innerContent = innerContent.replace(/stroke-width="[^"]*"/g, '');

      const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${viewBox}" fill="none" stroke="black" stroke-width="1" stroke-linecap="round" stroke-linejoin="round">${innerContent}</svg>`;

      const encoded = svg
        .replace(/"/g, "'")
        .replace(/%/g, '%25')
        .replace(/#/g, '%23')
        .replace(/{/g, '%7B')
        .replace(/}/g, '%7D')
        .replace(/</g, '%3C')
        .replace(/>/g, '%3E')
        .replace(/\n/g, '%0A');

      return `data:image/svg+xml,${encoded}`;
    }

    css += maskStyles;

    await fs.writeFile(cssPath, css);

    // Generate minified CSS
    const minCss = css
      .replace(/\/\*[\s\S]*?\*\//g, '') // Remove comments
      .replace(/\s+/g, ' ') // Collapse whitespace
      .replace(/\s*{\s*/g, '{') // Remove space around {
      .replace(/\s*}\s*/g, '}') // Remove space around }
      .replace(/\s*:\s*/g, ':') // Remove space around :
      .replace(/\s*;\s*/g, ';') // Remove space around ;
      .replace(/;}/g, '}') // Remove last semicolon before }
      .trim();

    const minCssPath = path.resolve(__dirname, '../dist/uniline.min.css');
    await fs.writeFile(minCssPath, minCss);

    console.log('‚úÖ Icon font generated successfully!');
    console.log(`üìä Total icons: ${outlineSvgs.length + solidSvgs.length} (${outlineSvgs.length} outline + ${solidSvgs.length} filled)`);
    console.log(`üìä CSS classes: ${outlineSvgs.length + solidSvgs.length}`);
    console.log('‚ú® Outline icons use CSS mask-image for color support');
    console.log('‚ú® Filled icons use standard icon font glyphs');
    console.log('üìÅ Check dist/index.html for preview');

  } catch (error) {
    console.error('‚ùå Error generating icon font:', error);
    console.error(error.stack);
    process.exit(1);
  }
}

generateIconFont();
